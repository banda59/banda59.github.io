<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VMProtect Devirtualization Deobfuscation Part 01</title>

    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../blog.css">

    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link href="https://cdn.jsdelivr.net/gh/sun-typeface/SUITE@2/fonts/static/woff2/SUITE.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        body {
            font-family: 'Sweet400', sans-serif;
            font-weight: 400; /* 기본 굵기 */
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Sweet800', sans-serif;
            font-weight: 800; /* 제목에는 더 굵은 굵기를 적용합니다. */
        }

        /* 코드 블록은 폰트 적용에서 제외하고 고정폭 폰트를 사용합니다. */
        pre, code, kbd, samp {
            font-family: 'Consolas', 'Monaco', 'Menlo', monospace;
        }

        /* strong, b 태그가 굵게 표시되도록 수정 */
        strong, b {
            font-weight: 800;
        }

        .post-content img {
            max-width: 100%;
            height: auto;
            /* 이미지를 가운데 정렬합니다. */
            display: block;
            margin: 25px auto;
            /* 보라색 테두리와 약간의 안쪽 여백, 둥근 모서리를 추가합니다. */
            border: 3px solid #b091ff;
            border-radius: 8px;
            padding: 5px;
            box-sizing: border-box;
        }

        .post-content {
            /* 본문 글자 크기를 키웁니다. */
            font-size: 1.1em;
            line-height: 1.7;
        }

        /* 모바일 반응형 스타일 */
        @media (max-width: 768px) {
            .single-post-container .main-content {
                /* 모바일 화면에 맞게 좌우 패딩을 줄입니다. */
                padding: 20px 15px;
            }

            .post-title-full {
                /* 제목 폰트 크기를 모바일에 맞게 조정합니다. */
                font-size: 2em;
            }

            .post-content {
                /* 본문 폰트 크기와 줄 간격을 조정하여 가독성을 높입니다. */
                font-size: 1.05em;
                line-height: 1.75;
            }

            /* 코드 블록이 가로 스크롤되도록 설정합니다. */
            .post-content pre {
                white-space: pre;
                overflow-x: auto;
            }
        }

        #c {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        body.standalone-post {
            background-color: #000;
        }

        body.standalone-post .single-post-container {
            background: #16181d; /* Dark background for content */
            color: #bcbcff;      /* Main text color: very light blue-purple */
            max-width: 900px;
            margin: 40px auto;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Inline code style (like Notion's Ctrl+E) */
        body.standalone-post .post-content :not(pre)>code {
            color: #d291ff; /* Fluorescent-like purple */
            background-color: rgba(255, 255, 255, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 90%;
        }

        /* Link color on dark background */
        body.standalone-post .post-content a {
            color: #9c87fa; /* LightSkyBlue for good contrast */
        }

        /* Full code blocks (pre > code) style for dark mode */
        body.standalone-post .post-content pre .hljs {
            background: #121418; /* Darker than the container */
            border-radius: 4px;
        }

        @media (max-width: 940px) {
            body.standalone-post .single-post-container {
                margin: 20px;
            }
        }

        @media (max-width: 768px) {
            body.standalone-post .single-post-container {
                margin: 0;
                border-radius: 0;
                box-shadow: none;
            }
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <div class="single-post-container">
        <main class="main-content">
            <article class="post-full">
                <header class="post-header">
                    <a href="../index.html" class="back-to-list">&larr; Back to List</a>

                    <h1 class="post-title-full">VMProtect Devirtualization Deobfuscation Part 01</h1>

                    <p class="post-meta">
                        <time datetime="2025-09-11">September 11, 2025</time> | By banda |
                        <span class="post-tags">
                            <a href="../index.html?tag=Rev">Rev</a>
                        </span>
                    </p>
                </header>

                <section class="post-content">
                    <h1>Introduction</h1>
<p><img src="../assets/post02/image1.jpg" alt=""></p>
<p>안녕하세요. 오늘도 어디서인가 돌아온 banda입니다.</p>
<p>코드 난독화를 수행하는 대표적인 프로그램 중에 VMProtect, Themida가 있는데요. 이 중 VMProtect는 특히 가상머신(VM) 기반의 가상화, 난독화를 수행하는 프로그램으로 알려져 있습니다. VMProtect는 non-standard 가상 아키텍처를 통해 원본 코드를 독자적인 바이트코드로 변환하면서 정적 분석, 동적 분석을 매우 어렵게 만듭니다.</p>
<p>그간 VMProtect 난독화 해제를 시도하려는 논문과 연구가 꾸준히 제공되어 왔는데, 오늘 필자는 이와 같은 연구 중 특히 LLVM을 활용한 난독화 해제 방법론을 중심으로 살펴보고, 난독화 해제가 어느 실현 가능할지 살펴보려고 합니다. (다만 이번 글에서는 VMP 보호 옵션 중 가상화 옵션에 대해서만 집중적으로 다룹니다.)</p>
<h1>VMProtect</h1>
<p><img src="../assets/post02/image2.png" alt=""></p>
<p>VMProtect는 Anti-Reversing 기법을 적용해 소프트웨어를 보호하는 프로그램입니다. 공식 문서에 따르면 애플리케이션 코드 보호와 크랙 방지를 위해 사용되며, 자체 스크립트 언어와 내장 디스어셈블러를 제공해 보호할 코드 영역과 빌드 동작을 세밀하게 제어할 수 있고, 주로 Windows 기반 네이티브 애플리케이션(C/C++, Delphi, Visual Basic)을 대상으로 바이너리 난독화를 수행합니다.</p>
<p>VMProtect 3.9.6 기준으로 난독화 옵션은 ①Memory Protection, ②Import Protection, ③Resource Protection, ④Pack the Output File, ⑤Debugger Detection, ⑥Virtualization Tools Dectection, ⑦Virtualization이 존재합니다.
이 중에서도 **Virtualization(가상화)**은 강력한 보호 기법으로, 원래의 x86/x64 코드를 VMProtect가 <strong>정의한 커스텀 바이트코드</strong>로 변환한 뒤, 실행 시 내장된 가상머신이 이를 해석해 동작하는 방식입니다. 또한 하나의 바이너리 안에서도 여러 종류의 VM이 혼합될 수 있으며, 엔트리포인트를 포함해 다양한 위치를 선택적으로 가상화할 수 있습니다.</p>
<h1>VMProtect with LLVM</h1>
<p>LLVM을 활용한 VMProtect 분석은 그동안 VM의 내부 구조를 이해하려는 정적 리프팅(Static Lifting)과, 내부 구조 대신 동작 결과에 집중하는 동적 트레이싱(Dynamic Tracing) 두 가지 케이스로 연구가 진행된 바 있습니다.</p>
<ul>
<li>정적 리프팅 (Static Lifting)</li>
</ul>
<p>첫 번째 접근법에서는 VM 내부를 White-Box로 간주해 정적 리프팅하는 방식을 사용하고 있습니다. 이 접근법을 확인해보면  <code>VmHandler</code>(VMProtect에서 VM을 구성하는 각 가상 명령어 핸들러)를 일일이 리버싱하여 그 동작을 분석하고, 이를 C++를 통해 <code>Helper Function</code>로 재구현합니다. 이후 보호된 코드의 VM 바이트코드를 이 <code>Helper Function</code> 호출의 연속으로 번역해 전체 프로그램을 LLVM-IR로 변환하는 방식을 사용하고 있습니다. 다만 위 접근법을 사용하기 위해 VM 아키텍처에 대한 깊은 이해가 필요합니다. <a href="https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html">(reference)</a></p>
<ul>
<li>동적 트레이싱 (Dynamic Tracing)</li>
</ul>
<p>두 번째 접근법은 동적 트레이싱을 통해 VM을 실행시켜 <strong>입력과 출력 사이의 관계만 추적해 함수 난독화를 해제</strong>하는 Black-Box 방식을 사용하고 있습니다. 특정 입력을 주고 프로그램을 실행해 실행된 모든 명령어를 ‘trace’로 기록하고, 이 흔적을 심볼릭 실행으로 재구성해 입출력 관계식을 도출합니다. <a href="https://github.com/JonathanSalwan/VMProtect-devirtualization">(reference)</a></p>
<p><strong>LLVM IR과 SSA (Single Static Assignment)</strong></p>
<p><img src="../assets/post02/image3.png" alt=""></p>
<p>LLVM IR은 <strong>SSA(Static Single Assignment)</strong> 형식을 기반으로 하는 중간 표현(Intermediate Representation, IR)을 사용합니다. SSA(Static Single Assignment)란, 변수가 한 번만 할당된다는 원칙을 따르며, 새로운 값이 계산될 때마다 새로운 가상 레지스터(SSA 변수)가 생성되는 원리를 가지고 있습니다. 아래 어셈블리 코드와 LLVM IR 코드를 비교해봅시다.</p>
<pre><code class="language-python">add rax, rcx
sub rdx, rbx
sub rax, rdx
</code></pre>
<pre><code class="language-llvm">%rax2 = add i64 %rax, %rcx
%rdx2 = sub i64 %rdx, %rbx
%rax3 = sub i64 %rax2, %rdx2
</code></pre>
<p>LLVM IR 코드에서는 <code>%rax1</code>, <code>%rax2</code>처럼 변수 이름이 계속 바뀌는 것을 확인할 수 있는데요. 이유는 한 번 정의된 SSA 변수가 다시 덮어쓰지 않는다는 원칙 때문이겠죠?! 따라서 데이터 흐름과 연산 결과를 명확히 추적할 수 있다는 장점을 가지고 있습니다.</p>
<p><strong>이런 SSA 형식의 LLVM-IR이 왜 VMProtect 가상화 해제에 중요할까요?</strong></p>
<p>VMProtect의 가상화 핸들러는 수천 개, 그 이상의 비트 연산, 시프트, 산술 연산을 뒤섞어 노이즈를 만들며, 원래 연산을 감추기 위해 **MBA(Mixed Boolen-Arithmetic)**과 같은 복잡한 수식을 생성합니다. VMProtect 가상화의 MBA 표현식의 예는 아래와 같습니다.</p>
<pre><code class="language-llvm">(bvor
    (bvnot (bvor (bvnot (bvnot x)) (bvnot y)))
    (bvnot (bvor (bvnot x) (bvnot (bvand (bvnot y) (bvnot y)))))
)
</code></pre>
<p>위 식은 단순한 <code>x^y</code> 연산과 동일하지만, 직관적으로 파악하기는 어렵죠?</p>
<p>이처럼 복잡하게 형성되어있는 표현식을 SSA 기반의 LLVM IR로 변환하면 데이터 흐름이 명확해지고, LLVM 최적화(Constant Propagation, Dead Code Elimination, Pattern Recognition 등)를 통해 불필요한 연산과 노이즈를 제거할 수 있습니다. 결과적으로 수만 개의 VMP 명령어가 수십 개의 SSA IR로 축약되면서 원본 연산에 가까운 형태를 복원할 수 있게 됩니다!</p>
<h1>Devirtualization</h1>
<p>이번 연구글에서는 정적 리프팅을 통해 VM 구조를 이해한 경험을 바탕으로, 동적 트레이싱 기반 해제 접근법을 참고했습니다. 또한 Jonathan Salwan의 <a href="https://github.com/JonathanSalwan/VMProtect-devirtualization"><strong>VMProtect-devirtualization Project</strong></a>를 활용하여 동적 트레이싱 기반 해제를 진행했습니다.</p>
<ul>
<li>pure function</li>
</ul>
<pre><code class="language-c">#include &lt;stdint.h&gt;
uint32_t f(uint32_t x) {
  x ^= 0xA3C59AC3u;
  x = (x &lt;&lt; 7) | (x &gt;&gt; 25);
  x += 0x9E3779B9u;
  return x;
}
</code></pre>
<p>실습 대상은 순수 함수(pure function)를 대상으로 하는데, 순수 함수란 같은 입력이면 항상 같은 출력을 내고, random, global, 변수, I/O 등에 의존하지 않습니다. 이러한 특성 덕분에 devirtualization에 적합합니다.</p>
<h3><strong>How It Works?</strong></h3>
<pre><code class="language-llvm">가상화된 코드의 실행 기록 (T’) =
원본 코드의 실행 기록 (T) + 가상 머신(VM) 명령어의 실행 기록 (VM(T))
</code></pre>
<p>**실행기록(Trace)**은 프로그램이 실행될 때 CPU가 처리한 명령어들의 목록을 시간 순서대로 받아 적은 것이라고 보면 쉽습니다.  목표는 T’에서 VM(T)라는 노이즈를 제거하고 순수한 T를 복원하는 것이고, 동작 원리는 아래의 5단계 절차를 확인해봅시다.</p>
<ol>
<li>
<p><strong>Identify the virtualized function and its arguments</strong></p>
<p>전체 프로그램 중 어떤 부분이 VMProtect로 보호되어 있는지, 그리고 보호된 함수가 어떤 인자를 받아서 처리하는지 찾아냅니다.</p>
</li>
<li>
<p><strong>Generate a VMProtect Trace of the target</strong></p>
<p>(단계 1)에서 찾아낸 보호된 함수를 실제로 실행시켜, 어떤 명령어들이 어떤 순서로 실행되는지(CPU가 처리하는 모든 명령어 목록) 전체 기록(trace)를 수집합니다.</p>
</li>
<li>
<p><strong>Construct symbolic expressions to obtain the relation between inputs and output</strong></p>
<p>(단계 2)에서 얻은 명령어 기록을 분석합니다. 실제 값 대신 변수(symbolic variable)을 사용해서, 프로그램이 내부적으로 어떤 계산을 하는지 수학 표현식으로 정리합니다.</p>
</li>
<li>
<p><strong>Apply optimizations on symbolic expressions to avoid as much as possible instructions from the VM</strong></p>
<p>(단계 3)에서 만든 수학 표현식을 간단하게 정의하고, 이 과정에서 VM을 실행시키기 위한 불필요한 명령어들에 해당되는 부분을 제거합니다.</p>
</li>
<li>
<p><strong>Lift our symbolic representation to the LLVM-IR</strong></p>
<p>(단계 4)에서 찾아낸 핵심 로직을 LLVM-IR(특정 CPU에 종속되지 않는 범용적인 코드 형태) 중간 단계 코드로 변환합니다. 이때 이 LLVM-IR을 다시 컴파일 하면, VMProtect 보호가 적용되지 않은 깨끗한 버전의 원본 프로그램을 최종적으로 만들어낼 수 있다고 합니다.</p>
</li>
</ol>
<p>이 과정을 통해 최종적으로 VMProtect 난독화가 제거된 LLVM-IR을 얻을 수 있습니다.</p>
<h3>Example: Bitwise Function</h3>
<pre><code class="language-c">int bitwise_func(int a, int b, int flag) {
    VMProtectBegin(&quot;bitwise_func&quot;);
    int r;
    if (flag == 0)
        r = a &amp; b;
    else if (flag == 1)
        r = a | b;
    else
        r = a ^ b;
    VMProtectEnd();
    return r;
}
</code></pre>
<p>제공된 예제에서는 단순 산술 연산을 선정했지만 저는 control flow를 포함하는 코드를 빌드했습니다. 참고로 단순 연산 코드가 아닌 분기문을 포함한 함수를 분석하기 위해서는 trace를 여러 개 생성해야만 로직을 복원할 수 있습니다. LLCM-IR 모듈은 CFG(Control Flow Graph)를 가지고 있기 때문에, 각 분기문으로부터 얻은 trace들을 CFG로 병합하기 위해 추가적인 과정이 필요합니다.</p>
<p><img src="../assets/post02/image4.png" alt=""></p>
<p>VMProtect에서 가상화 옵션을 적용하기 전후 바이너리를 비교해보면 파일 크기가 어마어마하게 커지는 것을 볼 수 있습니다. 원본 코드가 VMProtect의 바이트코드로 변환되고, 이를 해석하고 실행하기 위한 가상머신(Interpreter)이 바이너리에 추가되었기 때문입니다. (여담이지만 이러한 크기 증가의 부담때문에 난독화할 때 해당 옵션을 적용하지 않는 경우도 드물지 않다고 하네요.. 하지만 그대신 난독화 효과는 강력했습니다.)</p>
<p><img src="../assets/post02/image5.png" alt=""></p>
<p>가상화 옵션이 적용된 bitwise.vmp.bin 파일을 확인해보면 몇 가지 특이한 점을 볼 수 있는데요. 저의 경우와 같이 기본적인 VMProtect 가상화 옵션 적용만으로 함수의 RVA가 변경되지 않습니다만, option에 따라 변경될 수도 있습니다. 또한 <code>ret</code> 없이 <code>jmp</code>를 통해 <code>loc_407675</code>로 점프되면서 원래 코드가 아닌, VMProtect 시작 지점으로 흐름이 넘어가는 모습이 가상화의 대표적인 특징으로 볼 수 있었습니다.</p>
<p><img src="../assets/post02/image6.png" alt=""></p>
<p><code>loc_407675</code>로 들어가봅시다. 초기에 <code>push 3987A4B2h</code>, <code>call sub_4A4BBB</code>, <code>int 3</code>을 통해 스택에 <code>3987A4B2h</code> context 값을 넣고, <code>sub_4A4BBB</code> 함수를 호출하면서 인터프리터에 진입합니다.</p>
<p>이후 <code>VmHandler</code>라는 코드 블록을 수행하는데요. <code>call</code> 명령어로 진입한 루프 내부에서 VIP를 이용해 바이트코드를 읽어오고 HANDLER 위치를 찾아내 특정 연산을 수행하는 가상 명령어 처리 과정을 반복합니다.</p>
<h3><strong>Trace 수집 (Intel Pin)</strong></h3>
<p><strong>📌Pin이란</strong></p>
<p><img src="../assets/post02/image7.png" alt=""></p>
<p>Pin은 Intel에서 제공하는 동적 바이너리 계측(DBI) 프레임워크로, Windows와 Linux 환경의 x86 및 x64 바이너리를 지원합니다. Pin은 프로그램을 직접 수정하지 않고 JIT(Just-In-Time) 기반 코드 변환을 통해 실행 흐름에 개입하며, 사용자가 작성한 pintool을 삽입해 명령어 실행, 메모리 접근, 함수 호출 등 런타임 동작을 관찰하고 기록할 수 있습니다.</p>
<p>이러한 Pin의 특성을 활용하면, JIT 단계에서 실행 흐름을 가로채 사용자 정의 pintool을 주입하고, 지정한 구간의 trace를 효과적으로 수집할 수 있습니다.</p>
<pre><code class="language-c">TRACE_AddInstrumentFunction(OnTrace, 0);

VOID OnTrace(TRACE t, VOID*) {
  for (BBL b = TRACE_BblHead(t); BBL_Valid(b); b = BBL_Next(b)) {
    for (INS i = BBL_InsHead(b); INS_Valid(i); i = INS_Next(i)) {
      // 실제 훅 삽입
    }
  }
}
// 등록
TRACE_AddInstrumentFunction(OnTrace, 0);
</code></pre>
<p>Pin의 동작은 다음과 같은 순서를 따릅니다.</p>
<ol>
<li>프로그램이 실행될 때 Pin이 <strong>코드 블록(Trace)</strong> 실행을 가로챕니다.</li>
<li>Pin은 해당 Trace를 즉시 실행하지 않고, 사용자가 등록한 <code>콜백 함수(OnTrace)</code>를 먼저 호출합니다.</li>
<li>OnTrace 내부에서 분석 코드를 삽입하거나, 원하는 명령어에 대해 hook을 추가할 수 있습니다. (일명 코드 끼워넣기)</li>
<li>원본 코드와 삽입된 분석 코드가 합쳐져 JIT 컴파일되며, 결과적으로 프로그램은 “원본 동작 + 기록 기능”을 동시에 수행합니다.</li>
</ol>
<p>위 과정을 통해 Pin은 실행된 모든 기계어 명령어를 왜곡 없이 기록할 수 있게 됩니다.</p>
<pre><code class="language-c">./pin -t ./source/tools/VMP_Trace/obj-intel64/VMP_Trace.so \
  -start 0x401156 -end 0x4011AA \
  -- ./bitwise.vmp.bin 0 &amp;&gt; ./bitwise.vmp.trace
</code></pre>
<p>Trace를 수집하기 위해서는 이전에 확인했던 정적 분석을 통해서 분석하고자 하는 함수의 start address(<code>0x401156</code>), end address(<code>0x4011AA</code>), 그리고 인자가 몇 개 들어가는지 정도 확인해주면 됩니다. 이 주소 범위를 바탕으로, Intel Pin 도구를 사용해 trace를 수집합니다.</p>
<p><img src="../assets/post02/image8.png" alt=""></p>
<p>생성된 trace 파일 내부를 살펴보면, pin을 사용해 bitwise.vmp.bin을 <code>flag=0</code> 인자와 함께 실행했을 때, 지정한 범위 내에서 CPU가 실행한 모든 기계어 명령어 기록을 담고 있음을 확인할 수 있습니다. 파일 구조를 확인해보면 <code>r:</code>, <code>i:</code>를 한 쌍으로 기록하는 형식을 가지고 있습니다.</p>
<ul>
<li><code>r:</code> (Registers): <code>i:</code> 가 실행되기 이전의 모든 CPU 범용 레지스터 상태를 16진수 값으로 기록한 형태를 담고 있습니다.</li>
<li><code>i:</code> (Instruction): 실제로 실행된 명령어 자체에 대한 정보이며, <code>i:&lt;명령어 주소&gt;:&lt;명령어 크기(byte)&gt;:&lt;기계어 코드(Opcode)&gt;</code> 로 구성되어 있습니다. 예를들면 <code>i:0x401156:1:55</code>는 <code>0x401156</code>이라는 시작 주소를 정확하게 담고있고, ‘<code>0x55</code>(<code>push rbp</code>) 명령어를 실행했다’는 방식으로 해석할 수 있습니다!</li>
</ul>
<p>하지만 생성된 trace 파일은 인간이 전부 읽기에는 방대하기 때문에 불가능에 가깝습니다.. attack_vmp.py 같은 도구를 사용해 원본 로직을 담은 LLVM-IR을 생성해봅시다.</p>
<p><strong>vbraddr(Virtual Branch Address) 구하기</strong></p>
<p><img src="../assets/post02/image9.png" alt=""></p>
<p>저의 경우와 같이 분기문을 포함한 함수의 <strong>전체 로직을 복원하기 위해서는</strong>, 서로 다른 실행 경로를 담고 있는 여러 개의 Trace 파일을 동시에 분석해야 합니다. 그런데 VMProtect는 일반적인 <code>jmp</code>, <code>jz</code>, <code>jnz</code> 같은 직접적인 분기 명령어를 사용하지 않고 가상화된 분리 로직을 사용합니다. 이 경우 attack 스크립트는 이 경로들이 정확히 어느 지점에서 갈라졌는지 자동으로 파악하기 어렵습니다.</p>
<p>이 vbraddr 주소 값을 인간이 IDA로 찾아서 넣어주도록 합시다. trace 상에서 cmp나 test 같은 비교 명령어가 위치한 부분 중 가상 분기를 결정하는 부분을 정확히 찾아주면 됩니다. 필자의 경우에는 <code>0x4831A5</code>가 가상 분기 주소에 해당했습니다. 그리고 이 vbraddr이 후에 CFG가 갈라지는 기준점을 명시하는 역할이 되어줍니다.</p>
<p><img src="../assets/post02/image10.png" alt=""></p>
<p>attack_vmp.py 스크립트의 동작 방식을 살펴봅시다. 해당 스크립트는 <a href="https://github.com/jonathansalwan/Triton">Triton 프레임워크</a>를 기반으로 동작합니다.</p>
<ul>
<li>Triton은 Trace 내의 실행된 명령어를 하나씩 해석하면서 레지스터와 메모리를 심볼릭 변수(symbolic variable)로 추적합니다.</li>
<li>이 과정에서 레지스터와 메모리 상태가 AST(Abstract Syntax Tree) 형태로 관리됩니다.</li>
<li>Triton의 symbolic execution 엔진을 통해 path predicate를 구축하여 조건 분기까지 수학적으로 모델링합니다.</li>
<li>이를 통해 VMProtect 노이즈가 구체화(concretization) 단계에서 자동으로 상수 처리되어 제거되고, simplification pass와 formula slicing 기능을 활용해 최종적으로 표현식을 입력과 출력 관계만 담은 수학 표현식으로 단순화 하는 원리입니다.</li>
</ul>
<pre><code class="language-c">./attack_vmp.py \
  --trace1 ./bitwise.vmp.trace0 \
  --trace2 ./bitwise.vmp.trace1 \
  --trace3 ./bitwise.vmp.trace2 \
  --symsize 4 \
  --vbraddr 0x4831a5 \
  --vbrflag af
</code></pre>
<p>스크립트 명령어로 각각 다른 분기문을 타는 trace 세 개 파일을 넣어주고, <code>—vbraddr</code>과 <code>—vbrflag</code> 옵션을 함께 전달해줍시다. 참고로 기존에 제공된 attack_vmp 스크립트는 trace를 두 개까지 밖에 못 줘서 trace 파일을 더 많이 줬을 때 이를 연결지어 LLVM-IR로 결합할 수 있는 스크립트 기능으로 조금 확장해봤습니다. 과연 세 개의 분기문을 병합해 CFG 형식으로 복원할 수 있을까요?</p>
<p><img src="../assets/post02/image11.png" alt=""></p>
<p>생성된 LLVM-IR을 확인해보면 원본 코드의 <code>if-else</code> 구조와 비트 연산(XOR, AND, OR) 조합을 정확하게 구현했다는 점을 알 수 있습니다. (<a href="https://llvm.org/docs/LangRef.html">LLVM-IR Language</a>가 궁금하다면 이 곳에서 확인할 수 있습니다.)</p>
<p>LLCM IR 리프팅 결과, <code>%SymVar_0</code>, <code>%SymVar_1</code>에 대해 처음에는 AND와 OR 연산이, 그 다음에 XOR 연산이 각각 조건 검사를 거쳐 결과를 선택한다는 점을 확인할 수 있었습니다. <code>-88</code>, <code>==16</code> 같은 불필요한 비교는 VMProtect 가상화 과정에서 삽입된 노이즈이지만, 핵심 로직과 무관합니다.</p>
<p><img src="../assets/post02/image12.png" alt=""></p>
<p>위 그래프는 VMProtect로 가상화된 함수를 devirtualization 과정에서 복원한 결과로, 함수의 반환 값이 select 연산에 의해 결정되는 구조를 보여줍니다. 첫 번째 select 노드는 cond q라는 조건에 따라 왼쪽으로는 <code>SymVar_0</code>과 <code>SymVar_1</code>을 XOR한 결과를, 오른쪽으로는 또 다른 select 노드의 결과를 선택하고 있습니다. 오른쪽의 select 노드는 cond p 조건에 따라 참일 경우 <code>SymVar_0</code>과 <code>SymVar_1</code>을 OR한 결과를, 거짓일 경우 <code>SymVar_0</code>과 <code>SymVar_1</code>을 AND한 결과를 선택합니다.</p>
<h1>Conclusion</h1>
<p>사실 이번 글에서 다룬 LLVM 기반의 devirtualization 접근법은 단일 경로나 소수의 실행 경로를 가진 함수에서는 효과적이지만, 경로 수가 많은 프로그램에서는 일부 코드가 누락될 수 있기 때문에 현실적인 규모의 코드에 해당 접근법을 적용하기에는 아직 무리가 있었습니다. 따라서 이번 연구글은 여기서 part 1을 마무리하려고 합니다.</p>
<p>다음 part에서는 관련 논문들을 기반으로 정적 분석을 중점에 두어 devirtualization 가능성을 담아보고, virtualization 뿐만이 아닌 다양한 options에 대한 난독화 해제 접근법을 살펴보겠습니다! 감사합니다.</p>

                </section>
            </article>
        </main>
    </div>

    <script>
    const runStarfield = () => {
      'use strict';

      const files = [
        "1.png", "2.png", "3.png", "4.png", "5.png", "6.png", "7.png", "9.png", "10.png"
      ].map(n => "../../sprites/" + n);

      const OBJ_MIN = 18;
      const OBJ_MAX = 28;

      const OBJ_L_MIN = 1;
      const OBJ_L_MAX = 2;

      const OBJ_SC_MIN = 0.15;
      const OBJ_SC_MAX = 0.26;

      const OBJ_PAD = 10;
      const OBJ_SAME_EXTRA = 60;

      const STAR_DOT_SCALE = 1.0;
      const STAR_SPARKLE_SCALE = 1.35;

      const OBJ_FADE_RATIO = 0.30;
      const OBJ_FADE_MIN_A = 0.05;
      const OBJ_FADE_MAX_A = 1.00;
      const OBJ_FADE_PERIOD_MIN = 6;
      const OBJ_FADE_PERIOD_MAX = 12;

      const cv = document.getElementById('c');
      if (!cv) return;
      const ctx = cv.getContext('2d', { alpha: false });

      let W = 0, H = 0, DPR = 1;
      let imgs = [];
      let stars = [];
      let sparkles = [];
      let objs = [];

      let seed = (Date.now() ^ (Math.random() * 0x7fffffff)) >>> 0;
      function rnd() { seed = (seed * 1664525 + 1013904223) >>> 0; return seed / 4294967296; }
      function clamp(x, a, b) { return x < a ? a : (x > b ? b : x); }

      function resize() {
        DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        W = Math.max(1, Math.floor(window.innerWidth));
        H = Math.max(1, Math.floor(window.innerHeight));

        cv.width = Math.floor(W * DPR);
        cv.height = Math.floor(H * DPR);
        cv.style.width = W + "px";
        cv.style.height = H + "px";

        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.imageSmoothingEnabled = false;

        buildStars();
        buildObjects();
      }

      function buildStars() {
        stars.length = 0;
        sparkles.length = 0;

        const area = W * H;

        const n = Math.max(900, Math.min(2600, Math.floor(area / 520)));
        for (let i = 0; i < n; i++) {
          const r = rnd();
          let size;
          if (r < 0.62) size = 1;
          else if (r < 0.86) size = 2;
          else if (r < 0.96) size = 3;
          else size = 4;

          size = Math.max(1, Math.round(size * STAR_DOT_SCALE));

          stars.push({
            x: rnd() * W,
            y: rnd() * H,
            s: size,
            ph: rnd() * Math.PI * 2,
            sp: 0.7 + rnd() * 0.9,
            base: 0.18 + rnd() * 0.35
          });
        }

        const m = Math.max(45, Math.min(120, Math.floor(area / 19000)));
        for (let i = 0; i < m; i++) {
          const rr = rnd();
          let size;
          if (rr < 0.55) size = 2;
          else if (rr < 0.85) size = 3;
          else size = 4;

          size = Math.max(2, Math.round(size * STAR_SPARKLE_SCALE));

          sparkles.push({
            x: rnd() * W,
            y: rnd() * H,
            size,
            ph: rnd() * Math.PI * 2,
            sp: 0.55 + rnd() * 0.7,
            duty: 0.20 + rnd() * 0.55,
            shape: rnd() < 0.65 ? 0 : 1,
            on: rnd() < 0.50
          });
        }
      }

      function drawStars(t) {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, W, H);

        for (let i = 0; i < stars.length; i++) {
          const st = stars[i];
          const v = st.base + (0.25 + 0.35 * Math.sin(t * st.sp + st.ph));
          if (v < 0.12) continue;

          const x = st.x | 0;
          const y = st.y | 0;
          const s = st.s | 0;

          ctx.globalAlpha = Math.min(1, v);
          ctx.fillStyle = "#fff";
          ctx.fillRect(x, y, s, s);
        }
        ctx.globalAlpha = 1;

        for (let i = 0; i < sparkles.length; i++) {
          const st = sparkles[i];
          const phase = (t * st.sp + st.ph) % (Math.PI * 2);
          const s = Math.sin(phase);

          const on = (st.on ? (s > (1 - st.duty)) : (s < (-1 + st.duty)));
          if (!on) continue;

          const x = st.x | 0;
          const y = st.y | 0;
          const size = st.size | 0;

          const a = 0.70 + 0.30 * Math.abs(s);
          ctx.globalAlpha = a;

          const len = (size * (2.1 + 0.8 * Math.abs(s))) | 0;

          ctx.fillStyle = "#fff";
          ctx.fillRect(x, y, size, size);

          for (let k = -len; k <= len; k += 1) {
            ctx.fillRect(x + k, y, 1, 1);
            ctx.fillRect(x, y + k, 1, 1);
          }

          if (st.shape === 1) {
            for (let k = -len; k <= len; k += 1) {
              ctx.fillRect(x + k, y + k, 1, 1);
              ctx.fillRect(x + k, y - k, 1, 1);
            }
          }
        }
        ctx.globalAlpha = 1;
      }

      function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
          const j = (rnd() * (i + 1)) | 0;
          const t = a[i]; a[i] = a[j]; a[j] = t;
        }
        return a;
      }

      function buildObjects() {
        objs.length = 0;
        if (!imgs.length) return;

        const area = W * H;
        let target = Math.round(area / 120000) + 12;
        target = clamp(target, OBJ_MIN, OBJ_MAX);

        const idxs = [];
        while (idxs.length < target) {
          const cycle = [];
          for (let i = 0; i < imgs.length; i++) cycle.push(i);
          shuffle(cycle);
          for (let i = 0; i < cycle.length && idxs.length < target; i++) idxs.push(cycle[i]);
        }

        const cell = Math.sqrt(area / (target * 1.15));
        const gx = Math.max(3, Math.floor(W / cell));
        const gy = Math.max(3, Math.floor(H / cell));
        const dx = W / gx;
        const dy = H / gy;

        const cand = [];
        for (let y = 0; y < gy; y++) {
          for (let x = 0; x < gx; x++) {
            const jx = (rnd() - 0.5) * dx * 0.30;
            const jy = (rnd() - 0.5) * dy * 0.30;
            cand.push({ x: (x + 0.5) * dx + jx, y: (y + 0.5) * dy + jy });
          }
        }
        shuffle(cand);

        let cpos = 0;
        let tries = 0;
        const maxTries = cand.length * 10;

        while (objs.length < target && tries < maxTries) {
          tries++;

          const idx = idxs[objs.length % idxs.length];
          const im = imgs[idx];

          const longSideTarget = Math.min(W, H) * (OBJ_L_MIN + (OBJ_L_MAX - OBJ_L_MIN) * rnd());
          const base = Math.max(im.width, im.height);
          let sc = longSideTarget / Math.max(1, base);
          sc = clamp(sc, OBJ_SC_MIN, OBJ_SC_MAX);

          const dw = Math.max(12, Math.round(im.width * sc));
          const dh = Math.max(12, Math.round(im.height * sc));

          const padEdge = Math.max(dw, dh) * 0.55 + 6;

          let x, y;
          if (cpos < cand.length) {
            x = cand[cpos].x; y = cand[cpos].y; cpos++;
          } else {
            x = padEdge + rnd() * (W - padEdge * 2);
            y = padEdge + rnd() * (H - padEdge * 2);
          }

          x = clamp(x, padEdge, W - padEdge);
          y = clamp(y, padEdge, H - padEdge);

          const r = (Math.max(dw, dh) * 0.55) + OBJ_PAD;

          let ok = true;
          for (let i = 0; i < objs.length; i++) {
            const o = objs[i];
            const dx2 = x - o.x;
            const dy2 = y - o.y;
            const d2 = dx2 * dx2 + dy2 * dy2;

            let need = r + o.r;
            if (o.idx === idx) need += OBJ_SAME_EXTRA;
            if (d2 < need * need) { ok = false; break; }
          }
          if (!ok) continue;

          const fade = (rnd() < OBJ_FADE_RATIO);
          const per = OBJ_FADE_PERIOD_MIN + (OBJ_FADE_PERIOD_MAX - OBJ_FADE_PERIOD_MIN) * rnd();
          const ph = rnd() * Math.PI * 2;

          objs.push({
            idx,
            x: x | 0,
            y: y | 0,
            dw: dw | 0,
            dh: dh | 0,
            r,
            fade,
            per,
            ph
          });
        }
      }

      function drawObjects(t) {
        for (let i = 0; i < objs.length; i++) {
          const o = objs[i];
          const im = imgs[o.idx];

          if (o.fade) {
            const s = 0.5 + 0.5 * Math.sin((t * (Math.PI * 2) / o.per) + o.ph);
            const a = OBJ_FADE_MIN_A + (OBJ_FADE_MAX_A - OBJ_FADE_MIN_A) * s;
            ctx.globalAlpha = a;
          } else {
            ctx.globalAlpha = 1;
          }

          ctx.drawImage(
            im,
            (o.x - o.dw / 2) | 0,
            (o.y - o.dh / 2) | 0,
            o.dw | 0,
            o.dh | 0
          );
        }
        ctx.globalAlpha = 1;
      }

      let t0 = performance.now();
      function frame(now) {
        const t = (now - t0) / 1000;
        drawStars(t);
        drawObjects(t);
        requestAnimationFrame(frame);
      }

      function loadOne(src) {
        return new Promise((resolve) => {
          const im = new Image();
          im.onload = () => resolve({ ok: true, im, src });
          im.onerror = () => resolve({ ok: false, src });
          im.src = src;
        });
      }

      async function loadAll() {
        const res = await Promise.all(files.map(loadOne));
        imgs = res.filter(x => x.ok).map(x => x.im);

        if (!imgs.length) {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, cv.width, cv.height);
          ctx.fillStyle = "#fff";
          ctx.font = "16px monospace";
          ctx.fillText("no sprites loaded", 20, 30);
          ctx.fillText("check page/sprites/*.png and file names", 20, 55);
          return;
        }

        resize();
        requestAnimationFrame(frame);
      }

      window.addEventListener('resize', resize, { passive: true });
      loadAll();
    };
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            if (window.hljs) hljs.highlightAll();

            // 페이지가 iframe 외부에서 직접 열렸는지 확인합니다.
            if (window.self === window.top) {
                // 직접 열렸을 경우, body에 클래스를 추가하여 배경과 레이웃을 변경합니다.
                document.body.classList.add('standalone-post');
                runStarfield();
            }
        });
    </script>
</body>

</html>